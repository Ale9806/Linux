{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Linux Tutorial Unix is a family of multitasking, multiuser computer operating systems that derive from the original AT&T Unix, development starting in the 1970s at the Bell Labs research center by Ken Thompson, Dennis Ritchie, and others. Linux is a family of open source Unix-like operating systems based on the Linux kernel, an operating system kernel first released on September 17, 1991, by Linus Torvalds. Linux is typically packaged in a Linux distribution. In simpler words: Linux is nothing but a UNIX clone which is written Linus Torvalds from scratch with the help of some hackers across the globe. Unix and Unix-like operating systems are a family of computer operating systems that derive from the original Unix System from Bell Labs which can be traced back to 1965. Linux is the most popular variant and there comes in a number of different distributions. Basic commands Overview: When working with linux we will wok on a terminal. In order to acomplish something we will need to use some basic commnads: Managing files and dirs Command Description pwd Print working directory ls Lists files in Directory ls -l Lists files in Directory with permission information ls -a Lists all files including those hidden cd Change Directory echo Prints messege in terminal touch Create an empty file mkdir Create new Directory rmdir Remove empty Directory cp Coppy file mv Move file (also renames files) chmod Change permissions of a file Operating with file content Command Description file file-name prints tpye of given file cat file-name Show contents of files wc file-name Counts the amount of characters, words, and lines in a file head file-name Show the first 10 lines of a file tail file-name Show the last 10 lines of a file grep file-name Find pattern in file cut file-name Extracts a given number of characters or columns from a file grep 'pattern' file-name Extracts patterns from file ADDITIONAL COMMANDS: Command Description date Prints the current date Who Prints the list of users currently logged into the computer man command Shows the manual page of the given command (press \"q\" to quit) uptime Shows how long the computer has been running free file-name Shows the amount of unused memory on the current system SIGNALS: Singals are tokens that allows us to control the behaviour of a program SPECIAL SIGNALS : kill is a specila signal, in has to be run from another therminal, therefore you need the Process Identifier (PID) to be able to stop the process: To find the PID you can use the ps comand SIGNALS + PROCESSES: Command Description ps Lists the processes executing in the current terminal for the current user ps ax Lists all processes currently executing for all users ps e Shows the environment for the processes listed kill PID Sends the SIGTERM signal to the process identified by PID (run this from another terminal) ctrl + c Termiantes a process properly ctrl + z Stop a process fg causes a job that was stopped or in the background to return to the foreground bg causes a job that was stopped to go to the background jobs lists the jobs currently running or stopped top shows the processes currently using the most CPU time (press \"q\" to quit) Chmod options: chmod -x : Make file executable chmod -r : Make file readable chmod -w : Make file writable chmod -rwx : All of the above","title":"Home"},{"location":"#linux-tutorial","text":"Unix is a family of multitasking, multiuser computer operating systems that derive from the original AT&T Unix, development starting in the 1970s at the Bell Labs research center by Ken Thompson, Dennis Ritchie, and others. Linux is a family of open source Unix-like operating systems based on the Linux kernel, an operating system kernel first released on September 17, 1991, by Linus Torvalds. Linux is typically packaged in a Linux distribution. In simpler words: Linux is nothing but a UNIX clone which is written Linus Torvalds from scratch with the help of some hackers across the globe. Unix and Unix-like operating systems are a family of computer operating systems that derive from the original Unix System from Bell Labs which can be traced back to 1965. Linux is the most popular variant and there comes in a number of different distributions.","title":"Linux Tutorial"},{"location":"#basic-commands-overview","text":"When working with linux we will wok on a terminal. In order to acomplish something we will need to use some basic commnads:","title":"Basic commands Overview:"},{"location":"#managing-files-and-dirs","text":"Command Description pwd Print working directory ls Lists files in Directory ls -l Lists files in Directory with permission information ls -a Lists all files including those hidden cd Change Directory echo Prints messege in terminal touch Create an empty file mkdir Create new Directory rmdir Remove empty Directory cp Coppy file mv Move file (also renames files) chmod Change permissions of a file","title":"Managing files and dirs"},{"location":"#operating-with-file-content","text":"Command Description file file-name prints tpye of given file cat file-name Show contents of files wc file-name Counts the amount of characters, words, and lines in a file head file-name Show the first 10 lines of a file tail file-name Show the last 10 lines of a file grep file-name Find pattern in file cut file-name Extracts a given number of characters or columns from a file grep 'pattern' file-name Extracts patterns from file","title":"Operating with file content"},{"location":"#additional-commands","text":"Command Description date Prints the current date Who Prints the list of users currently logged into the computer man command Shows the manual page of the given command (press \"q\" to quit) uptime Shows how long the computer has been running free file-name Shows the amount of unused memory on the current system","title":"ADDITIONAL COMMANDS:"},{"location":"#signals","text":"Singals are tokens that allows us to control the behaviour of a program","title":"SIGNALS:"},{"location":"#special-signals","text":"kill is a specila signal, in has to be run from another therminal, therefore you need the Process Identifier (PID) to be able to stop the process: To find the PID you can use the ps comand","title":"SPECIAL SIGNALS :"},{"location":"#signals-processes","text":"Command Description ps Lists the processes executing in the current terminal for the current user ps ax Lists all processes currently executing for all users ps e Shows the environment for the processes listed kill PID Sends the SIGTERM signal to the process identified by PID (run this from another terminal) ctrl + c Termiantes a process properly ctrl + z Stop a process fg causes a job that was stopped or in the background to return to the foreground bg causes a job that was stopped to go to the background jobs lists the jobs currently running or stopped top shows the processes currently using the most CPU time (press \"q\" to quit)","title":"SIGNALS + PROCESSES:"},{"location":"#chmod-options","text":"chmod -x : Make file executable chmod -r : Make file readable chmod -w : Make file writable chmod -rwx : All of the above","title":"Chmod options:"},{"location":"bash/","text":"Bash Scripting Introduction to BASH In a Unix like operating system, such as Linux, a shell takes input from you in the form of commands, processes it, and then gives an output. It is the interface through which a user works on the programs, commands, and scripts. A shell is accessed by a terminal which runs it. In order to visualize the shells you have available in your Linux distribrution type: user@desktop:~$ cat ~/../../etc/shells # /etc/shells: valid login shells /bin/sh /bin/dash /bin/bash /bin/rbash /usr/bin/tmux /usr/bin/screen In this tutorial we will use the born again shell (bash). In order to see the path of your shell run the following command: user@desktop:~$ which bash /bin/bash In order to run a program with bash we will have to add this path in every script we creat (take in mind that the file has to end in .sh) : user@desktop:~$ nano filename.sh #! /bin/bash # Add line echo \"HELLO BASH LINUX\" # Add line File Permission You can check the permission of files and directories with ls -l alex@LAPTOP-B501IEC8:~$ ls -l total 0 -rw-r--r-- 1 alex alex 162 Sep 23 23:57 01-What-is-Unix.md drwxrwxrwx 1 alex alex 4096 Sep 24 16:50 BMSIS .... The left column of this table contains a series of individual characters and dashes. The first hyphen (-) signifies that each of the entries in this list are files. If any of them were directories then instead of a hyphen there would be a d. Excluding the first hyphen we have the following string: rw-rw-r--. This string reflects the permissions that are set up for this file. There are three permissions that we can grant: r Read file w Write file x Execute file These three permissions can be granted on three different levels of access which correspond to each of the three sets of rwx in the permissions string: Owner of file Group Everyone else Levels of permmision: Character Meaning u The owner of the file g The group that the file belongs to o Everyone else a Everyone above Option: Character Meaning + Add permission - Remove permission = Set permission Permission: Character Meaning r Read a file w Write to or edit a file x Execute a file Example: If we want to make a file executable for the owner of this file (us). We can combine u, +, and x in order make the file executable. user@desktop:~$ chmod u+x [file] Basic arithmetic The Bash programming language can do very basic arithmetic, we have two options: expr The expr command can be used to evaluate Bash expressions. An expression is just a valid string of Bash code that, when run, produces a result. The arithmetic operators that you\u2019re already familiar with for addition (+), subtraction (-), and multiplication (*) work like you would expect them to. user@desktop:~$ nano math.sh #!/usr/bin/env bash # File: math.sh expr 5 + 2 expr 5 - 2 expr 5 \\* 2 expr 5 / 2 user@desktop:~$ bash math.sh 7 3 10 2 Notice that when doing multiplication you need to escape the star character, otherwise Bash thinks you\u2019re trying to create a regular expression! The division operator (/) does not work as you might expect it to since 5 / 2 = 2.5. Bash does integer division, which means that the result of dividing one number by another is always rounded down to the nearest integer. Bench Calculator If you want to do more complex math, for example math with fractions and numbers with decimals then us echo and the b ench c alculator program called bc . user@desktop:~$ nano math2.sh #!/usr/bin/env bash # File: math.sh echo \"22 / 7\" | bc -l echo \"4.2 * 9.15\" | bc -l echo \"(6.5 / 0.5) + (6 * 2.2)\" | bc -l user@desktop:~$ bash math2.sh 3.14285714285714285714 38.430 26.20000000000000000000 Variables In Bash you can store data in variables. Previously we have discussed environmental variables that are set by your operating system. You can also create your own variables. Make sure you follow these rules when you\u2019re naming variables: Every character should be lowercase. The variable name should start with a letter. The name should only contain alphanumeric characters and underscores. Words in the name should be separated by underscores. You can assign data to a variable using the equals sign (=). The data you store in a variable can either be a string or a number. No spaces on either side of the equals sign are allowed. a=5 In order to print the data in a variable, we can use echo. When you want to retrieve the value of a variable you must use the dollar sign ($) before the name of the variable. user@desktop:~$ a=5 user@desktop:~$ echo $a 5 You can modify the value of a variable using arithmetic operators by using the let command: user@desktop:~$ let a=$a+1 user@desktop:~$ echo $a 6 Occasionally you might want to run a command like you would on the command line and store the result of that command in a variable. We can do this by wrapping the command in a dollar sign and parentheses ($( )) around a command. This syntax is called command substitution. The command is executed and then gets replaced by the string that resulted from running the command. For example if we wanted to store the number of lines in math.sh user@desktop:~$ math_lines=$(cat math.sh | wc -l) user@desktop:~$ echo $math_lines 7 Variable names with a dollar sign can also be used inside other strings in order to insert the value of the variable into the string: user@desktop:~$ echo \"The file math.sh has $math_lines lines\" The file math.sh has 6 lines When writing a Bash script, the first argument to your script is stored in $1, the second argument is stored in $2, etc, etc. An array of all of the arguments passed to your script is stored in $@, and we\u2019ll discuss how to handle arrays later on user@desktop:~$ nano free.sh echo \"First variable $1 , second variable $2 , List of variables $@\" user@desktop:~$ bash free.sh blue red First variable blue , second variable red , List of variables blue red User Input You can ask the users to type in a string on the command line by temporarily stopping the execution of your program using the read command. user@desktop:~$ nano read_example.sh echo \"Type in a string and then press Enter:\" read response echo \"You entered: $response\" user@desktop:~$ bash read_example.sh Type in a string and then press Enter Hello world You entered: Hello world Arrays Arrays in Bash are ordered lists of values. You can create a list from scratch by assigning it to a variable name. Lists are created with parentheses () with a space separating each element in the list. Let\u2019s make a list of the plagues of Egypt: user@desktop:~$ plagues=(blood frogs lice flies sickness boils hail locusts darkness death) To retrieve the array you need to use parameter expansion, which involves the dollar sign and curly brackets (${ }). The positions of the elements in the array are numbered starting from zero. To get the first element of this array use ${plagues[0]} like so user@desktop:~$ echo ${plagues[0]} blood To get all of the elements of plagues use a star (*) between the square brackets: user@desktop:~$ echo ${plagues[*]} blood frogs lice flies sickness boils hail locusts darkness death Other useful things: You can find the length of an array using the pound sign (#) user@desktop:~$ echo ${#plagues[*]} 10 You can use the plus-equals operator (+=) to add an array onto the end of an array array: user@desktop:~$ dwarfs=(grumpy sleepy sneezy doc) # Command user@desktop:~$ echo ${dwarfs[*]} # Command grumpy sleepy sneezy doc # Output user@desktop:~$ dwarfs+=(bashful dopey happy) # Command user@desktop:~$ echo ${dwarfs[*]} # Output grumpy sleepy sneezy doc bashful dopey happy # Command Conditional Expressions Conditional execution allows you to control the circumstances where certain programs are executed based on whether those programs succeed or fail, but you can also construct conditional expressions which are logical statements that are either equivalent to true or false. Conditional expressions either compare two values, or they ask a question about one value. Conditional expressions are always between double brackets ([[ ]]), and they either use logical flags or logical operators. Logical Flag Meaning Usage -gt Greater Than [[ $planets -gt 8 ]] -ge Greater Than or Equal To [[ $votes -ge 270 ]] -eq Equal [[ $fingers -eq 10 ]] -ne Not Equal [[ $pages -ne 0 ]] -le Less Than or Equal To [[ $candles -le 9 ]] -lt Less Than [[ $wives -lt 2 ]] -e A File Exists [[ -e $taxes_2016 ]] -d A Directory Exists [[ -d $photos ]] -z Length of String is Zero [[ -z $name ]] -n Length of String is Non-Zero [[ -n $name ]] Example: [[ 3 -gt 4 ]] flase In addition to logical flags there are also logical operators. One of the most useful logical operators is the regex match operator =~. The regex match operator compares a string to a regular expression and if the string is a match for the regex then the expression is equivalent to true, otherwise it\u2019s equivalent to false. Let\u2019s test this operator a couple different ways: [[ rhythms =~ [aeiou] ]] && echo t || echo f my_name=sean [[ $my_name =~ ^s.+n$ ]] && echo t || echo f ## f ## t Here\u2019s a table of some of the useful logical operators in case you need to reference how they\u2019re used later: Logical Operator Meaning Usage =~ Matches Regular Expression [[ $consonants =~ [aeiou] ]] = String Equal To [[ $password = \"pegasus\" ]] != String Not Equal To [[ $fruit != \"banana\" ]] ! Not [[ ! \"apple\" =~ ^b ]] IF and Else Conditional expressions are powerful because you can use them to control how a Bash program that you\u2019re writing is executed. One of the fundamental constructs in Bash programming is the IF statement. Code written inside of an IF statement is only executed if a certain condition is true, otherwise the code is skipped. Let\u2019s write a small program with an IF statement: #!/usr/bin/env bash # File: condexif.sh if [[ $1 -gt 3 ]] && [[ $1 -lt 7 ]] then echo \"$1 is between 3 and 7\" elif [[ $1 =~ \"Jeff\" ]] || [[ $1 =~ \"Roger\" ]] || [[ $1 =~ \"Brian\" ]] then echo \"$1 works in the Data Science Lab\" else echo \"You entered: $1, not what I was looking for.\" fi Notes: It is important to put the if evaluation inside brackets and leave space among the expresison. After the if condition it is important to specify the behavior with the keyword then In order to close the loop write if Conditional execution uses two operators: AND (&&) and OR (||) which you can use to control what command get executed based on their exit status. Braces Bash has a very handy tool for creating strings out of sequences called brace expansion. Brace expansion uses the curly brackets and two periods ({ .. }) to create a sequence of letters or numbers. For example to create a string with all of the numbers between zero and nine you could do the following: user@desktop:~$ echo {0..9} 0 1 2 3 4 5 6 7 8 9 You can put strings on either side of the curly brackets and they\u2019ll be \u201cpasted\u201d onto the corresponding end of the sequence: user@desktop:~$ echo a{0..4} user@desktop:~$ echo b{0..4}c a0 a1 a2 a3 a4 b0c b1c b2c b3c b4c You can also combine sequences so that two or more sequences are pasted together: user@desktop:~$ echo {1..3}{A..C} 1A 1B 1C 2A 2B 2C 3A 3B 3C If you want to use variables in order to define a sequence you need to use the eval command in order to create the sequence: user@desktop:~$ start=4 user@desktop:~$ end=9 user@desktop:~$ echo {$start..$end} {4..9} user@desktop:~$ eval echo {$start..$end} 4 5 6 7 8 9 You can combine sequences with a comma between brackets ({,}): user@desktop:~$ echo {{1..3},{a..c}} 1 2 3 a b c For loop FOR loops iterate through every element of a sequence that you specify. Let\u2019s take a look at a small example FOR loop: #!/usr/bin/env bash # File: forloop.sh echo \"Before Loop\" for i in {1..3} do echo \"i is equal to $i\" done echo \"After Loop\" Notes: After giving the breace to iterate, specify the bahavior after do The closing keyword for for loop is not rof, but done While loop The WHILE loop begins first with the while keyword followed by a conditional expression. As long as the conditional expression is equivalent to true when an iteration of the loop begins, then the code within the WHILE loop will continue to be executed. #!/usr/bin/env bash # File: whileloop.sh count=3 while [[ $count -gt 0 ]] do echo \"count is equal to $count\" let count=$count-1 done Functions A function is a small piece of code that has a name. Writing functions allows us to re-use the same code multiple times across programs. Functions have the the following syntax: function [name of function] { # code here }","title":"Bash Scripting"},{"location":"bash/#bash-scripting","text":"","title":"Bash Scripting"},{"location":"bash/#introduction-to-bash","text":"In a Unix like operating system, such as Linux, a shell takes input from you in the form of commands, processes it, and then gives an output. It is the interface through which a user works on the programs, commands, and scripts. A shell is accessed by a terminal which runs it. In order to visualize the shells you have available in your Linux distribrution type: user@desktop:~$ cat ~/../../etc/shells # /etc/shells: valid login shells /bin/sh /bin/dash /bin/bash /bin/rbash /usr/bin/tmux /usr/bin/screen In this tutorial we will use the born again shell (bash). In order to see the path of your shell run the following command: user@desktop:~$ which bash /bin/bash In order to run a program with bash we will have to add this path in every script we creat (take in mind that the file has to end in .sh) : user@desktop:~$ nano filename.sh #! /bin/bash # Add line echo \"HELLO BASH LINUX\" # Add line","title":"Introduction to BASH"},{"location":"bash/#file-permission","text":"You can check the permission of files and directories with ls -l alex@LAPTOP-B501IEC8:~$ ls -l total 0 -rw-r--r-- 1 alex alex 162 Sep 23 23:57 01-What-is-Unix.md drwxrwxrwx 1 alex alex 4096 Sep 24 16:50 BMSIS .... The left column of this table contains a series of individual characters and dashes. The first hyphen (-) signifies that each of the entries in this list are files. If any of them were directories then instead of a hyphen there would be a d. Excluding the first hyphen we have the following string: rw-rw-r--. This string reflects the permissions that are set up for this file. There are three permissions that we can grant: r Read file w Write file x Execute file These three permissions can be granted on three different levels of access which correspond to each of the three sets of rwx in the permissions string: Owner of file Group Everyone else Levels of permmision: Character Meaning u The owner of the file g The group that the file belongs to o Everyone else a Everyone above Option: Character Meaning + Add permission - Remove permission = Set permission Permission: Character Meaning r Read a file w Write to or edit a file x Execute a file","title":"File Permission"},{"location":"bash/#example","text":"If we want to make a file executable for the owner of this file (us). We can combine u, +, and x in order make the file executable. user@desktop:~$ chmod u+x [file]","title":"Example:"},{"location":"bash/#basic-arithmetic","text":"The Bash programming language can do very basic arithmetic, we have two options:","title":"Basic arithmetic"},{"location":"bash/#expr","text":"The expr command can be used to evaluate Bash expressions. An expression is just a valid string of Bash code that, when run, produces a result. The arithmetic operators that you\u2019re already familiar with for addition (+), subtraction (-), and multiplication (*) work like you would expect them to. user@desktop:~$ nano math.sh #!/usr/bin/env bash # File: math.sh expr 5 + 2 expr 5 - 2 expr 5 \\* 2 expr 5 / 2 user@desktop:~$ bash math.sh 7 3 10 2 Notice that when doing multiplication you need to escape the star character, otherwise Bash thinks you\u2019re trying to create a regular expression! The division operator (/) does not work as you might expect it to since 5 / 2 = 2.5. Bash does integer division, which means that the result of dividing one number by another is always rounded down to the nearest integer.","title":"expr"},{"location":"bash/#bench-calculator","text":"If you want to do more complex math, for example math with fractions and numbers with decimals then us echo and the b ench c alculator program called bc . user@desktop:~$ nano math2.sh #!/usr/bin/env bash # File: math.sh echo \"22 / 7\" | bc -l echo \"4.2 * 9.15\" | bc -l echo \"(6.5 / 0.5) + (6 * 2.2)\" | bc -l user@desktop:~$ bash math2.sh 3.14285714285714285714 38.430 26.20000000000000000000","title":"Bench Calculator"},{"location":"bash/#variables","text":"In Bash you can store data in variables. Previously we have discussed environmental variables that are set by your operating system. You can also create your own variables. Make sure you follow these rules when you\u2019re naming variables: Every character should be lowercase. The variable name should start with a letter. The name should only contain alphanumeric characters and underscores. Words in the name should be separated by underscores. You can assign data to a variable using the equals sign (=). The data you store in a variable can either be a string or a number. No spaces on either side of the equals sign are allowed. a=5 In order to print the data in a variable, we can use echo. When you want to retrieve the value of a variable you must use the dollar sign ($) before the name of the variable. user@desktop:~$ a=5 user@desktop:~$ echo $a 5 You can modify the value of a variable using arithmetic operators by using the let command: user@desktop:~$ let a=$a+1 user@desktop:~$ echo $a 6 Occasionally you might want to run a command like you would on the command line and store the result of that command in a variable. We can do this by wrapping the command in a dollar sign and parentheses ($( )) around a command. This syntax is called command substitution. The command is executed and then gets replaced by the string that resulted from running the command. For example if we wanted to store the number of lines in math.sh user@desktop:~$ math_lines=$(cat math.sh | wc -l) user@desktop:~$ echo $math_lines 7 Variable names with a dollar sign can also be used inside other strings in order to insert the value of the variable into the string: user@desktop:~$ echo \"The file math.sh has $math_lines lines\" The file math.sh has 6 lines When writing a Bash script, the first argument to your script is stored in $1, the second argument is stored in $2, etc, etc. An array of all of the arguments passed to your script is stored in $@, and we\u2019ll discuss how to handle arrays later on user@desktop:~$ nano free.sh echo \"First variable $1 , second variable $2 , List of variables $@\" user@desktop:~$ bash free.sh blue red First variable blue , second variable red , List of variables blue red","title":"Variables"},{"location":"bash/#user-input","text":"You can ask the users to type in a string on the command line by temporarily stopping the execution of your program using the read command. user@desktop:~$ nano read_example.sh echo \"Type in a string and then press Enter:\" read response echo \"You entered: $response\" user@desktop:~$ bash read_example.sh Type in a string and then press Enter Hello world You entered: Hello world","title":"User Input"},{"location":"bash/#arrays","text":"Arrays in Bash are ordered lists of values. You can create a list from scratch by assigning it to a variable name. Lists are created with parentheses () with a space separating each element in the list. Let\u2019s make a list of the plagues of Egypt: user@desktop:~$ plagues=(blood frogs lice flies sickness boils hail locusts darkness death) To retrieve the array you need to use parameter expansion, which involves the dollar sign and curly brackets (${ }). The positions of the elements in the array are numbered starting from zero. To get the first element of this array use ${plagues[0]} like so user@desktop:~$ echo ${plagues[0]} blood To get all of the elements of plagues use a star (*) between the square brackets: user@desktop:~$ echo ${plagues[*]} blood frogs lice flies sickness boils hail locusts darkness death Other useful things: You can find the length of an array using the pound sign (#) user@desktop:~$ echo ${#plagues[*]} 10 You can use the plus-equals operator (+=) to add an array onto the end of an array array: user@desktop:~$ dwarfs=(grumpy sleepy sneezy doc) # Command user@desktop:~$ echo ${dwarfs[*]} # Command grumpy sleepy sneezy doc # Output user@desktop:~$ dwarfs+=(bashful dopey happy) # Command user@desktop:~$ echo ${dwarfs[*]} # Output grumpy sleepy sneezy doc bashful dopey happy # Command","title":"Arrays"},{"location":"bash/#conditional-expressions","text":"Conditional execution allows you to control the circumstances where certain programs are executed based on whether those programs succeed or fail, but you can also construct conditional expressions which are logical statements that are either equivalent to true or false. Conditional expressions either compare two values, or they ask a question about one value. Conditional expressions are always between double brackets ([[ ]]), and they either use logical flags or logical operators. Logical Flag Meaning Usage -gt Greater Than [[ $planets -gt 8 ]] -ge Greater Than or Equal To [[ $votes -ge 270 ]] -eq Equal [[ $fingers -eq 10 ]] -ne Not Equal [[ $pages -ne 0 ]] -le Less Than or Equal To [[ $candles -le 9 ]] -lt Less Than [[ $wives -lt 2 ]] -e A File Exists [[ -e $taxes_2016 ]] -d A Directory Exists [[ -d $photos ]] -z Length of String is Zero [[ -z $name ]] -n Length of String is Non-Zero [[ -n $name ]] Example: [[ 3 -gt 4 ]] flase In addition to logical flags there are also logical operators. One of the most useful logical operators is the regex match operator =~. The regex match operator compares a string to a regular expression and if the string is a match for the regex then the expression is equivalent to true, otherwise it\u2019s equivalent to false. Let\u2019s test this operator a couple different ways: [[ rhythms =~ [aeiou] ]] && echo t || echo f my_name=sean [[ $my_name =~ ^s.+n$ ]] && echo t || echo f ## f ## t Here\u2019s a table of some of the useful logical operators in case you need to reference how they\u2019re used later: Logical Operator Meaning Usage =~ Matches Regular Expression [[ $consonants =~ [aeiou] ]] = String Equal To [[ $password = \"pegasus\" ]] != String Not Equal To [[ $fruit != \"banana\" ]] ! Not [[ ! \"apple\" =~ ^b ]]","title":"Conditional Expressions"},{"location":"bash/#if-and-else","text":"Conditional expressions are powerful because you can use them to control how a Bash program that you\u2019re writing is executed. One of the fundamental constructs in Bash programming is the IF statement. Code written inside of an IF statement is only executed if a certain condition is true, otherwise the code is skipped. Let\u2019s write a small program with an IF statement: #!/usr/bin/env bash # File: condexif.sh if [[ $1 -gt 3 ]] && [[ $1 -lt 7 ]] then echo \"$1 is between 3 and 7\" elif [[ $1 =~ \"Jeff\" ]] || [[ $1 =~ \"Roger\" ]] || [[ $1 =~ \"Brian\" ]] then echo \"$1 works in the Data Science Lab\" else echo \"You entered: $1, not what I was looking for.\" fi Notes: It is important to put the if evaluation inside brackets and leave space among the expresison. After the if condition it is important to specify the behavior with the keyword then In order to close the loop write if Conditional execution uses two operators: AND (&&) and OR (||) which you can use to control what command get executed based on their exit status.","title":"IF and Else"},{"location":"bash/#braces","text":"Bash has a very handy tool for creating strings out of sequences called brace expansion. Brace expansion uses the curly brackets and two periods ({ .. }) to create a sequence of letters or numbers. For example to create a string with all of the numbers between zero and nine you could do the following: user@desktop:~$ echo {0..9} 0 1 2 3 4 5 6 7 8 9 You can put strings on either side of the curly brackets and they\u2019ll be \u201cpasted\u201d onto the corresponding end of the sequence: user@desktop:~$ echo a{0..4} user@desktop:~$ echo b{0..4}c a0 a1 a2 a3 a4 b0c b1c b2c b3c b4c You can also combine sequences so that two or more sequences are pasted together: user@desktop:~$ echo {1..3}{A..C} 1A 1B 1C 2A 2B 2C 3A 3B 3C If you want to use variables in order to define a sequence you need to use the eval command in order to create the sequence: user@desktop:~$ start=4 user@desktop:~$ end=9 user@desktop:~$ echo {$start..$end} {4..9} user@desktop:~$ eval echo {$start..$end} 4 5 6 7 8 9 You can combine sequences with a comma between brackets ({,}): user@desktop:~$ echo {{1..3},{a..c}} 1 2 3 a b c","title":"Braces"},{"location":"bash/#for-loop","text":"FOR loops iterate through every element of a sequence that you specify. Let\u2019s take a look at a small example FOR loop: #!/usr/bin/env bash # File: forloop.sh echo \"Before Loop\" for i in {1..3} do echo \"i is equal to $i\" done echo \"After Loop\" Notes: After giving the breace to iterate, specify the bahavior after do The closing keyword for for loop is not rof, but done","title":"For loop"},{"location":"bash/#while-loop","text":"The WHILE loop begins first with the while keyword followed by a conditional expression. As long as the conditional expression is equivalent to true when an iteration of the loop begins, then the code within the WHILE loop will continue to be executed. #!/usr/bin/env bash # File: whileloop.sh count=3 while [[ $count -gt 0 ]] do echo \"count is equal to $count\" let count=$count-1 done","title":"While loop"},{"location":"bash/#functions","text":"A function is a small piece of code that has a name. Writing functions allows us to re-use the same code multiple times across programs. Functions have the the following syntax: function [name of function] { # code here }","title":"Functions"},{"location":"custom/","text":"Customizing Bash Basic information: The home directory is a special directory that is represented by a tilde (~). Your home directory contains your personal files, like your photos, documents,the contents of your desktop, and more imporantly, hidden files that allow us to add speciall functionality to Linux. When you first open up your shell you usually start off in your home directory. Hidden files can be created with \".\" at the begenning, .ignore for example. In linux we can visualize hidden files with ls -a user@desktop:~$ ls -a .bash_profile .config .linuxbrew .bashrc .git .ssh .nano .bash_history History We can acces and edit the content of .bash-history with nano .bash_history or we can use the history command to see the same content. The content of this file is all the commands we have run. Profile The ~/.bash_profile is a list of Unix commands that are run every time we open our terminal, usually with a different command on every line. Setting alias commands One of the most common commands used in a ~/.bash_profile is the alias command, which creates a shorter name for a command. Let\u2019s take a look at a ~/.bash_profile: user@desktop:~$ nano .bash_profile # Command alias docs='cd ~/Documents' # Line added alias edbp='nano ~/.bash_profile' # Line added We add an allias by: alias [alias_name]=\"code\" In order to make the changes to our ~/.bash_profile take effect we need to run source ~/.bash_profile in the console: user@desktop:~$ source ~/.bash_profile # Command user@desktop:~$ docs # Command user@desktop:~/Documents$ # New promt (output of docs) Environmental Variables The PATH variable contains a sequence of paths on our computer separated by colons. When the shell starts it searches these paths for executable files, and then makes those executable commands available in our shell. One approach to making our scripts available is to add a directory to the PATH. Bash scripts in the directory that are executable can be used as commands. We need to modify PATH every time we start a shell, so we can ammend our ~/.bash_profileso that our directory for executable scripts is always in the PATH. To modify an environmental variable we need to use the export keyword. First let\u2019s create a new directory called Commands in our Codedirectory where we can keep our executable scripts. Then we\u2019ll add a line to our ~/.bash_profile so that Commands is added to the PATH. user@desktop:~$ mkdir Commands user@desktop:~$ echo \"hello world\" > Commands/first.sh user@desktop:~$ nano ~/.bash_profile export PATH=~/Code/Commands:$PATH source ~/.bash_profile","title":"Customizing"},{"location":"custom/#customizing-bash","text":"","title":"Customizing Bash"},{"location":"custom/#basic-information","text":"The home directory is a special directory that is represented by a tilde (~). Your home directory contains your personal files, like your photos, documents,the contents of your desktop, and more imporantly, hidden files that allow us to add speciall functionality to Linux. When you first open up your shell you usually start off in your home directory. Hidden files can be created with \".\" at the begenning, .ignore for example. In linux we can visualize hidden files with ls -a user@desktop:~$ ls -a .bash_profile .config .linuxbrew .bashrc .git .ssh .nano .bash_history","title":"Basic information:"},{"location":"custom/#history","text":"We can acces and edit the content of .bash-history with nano .bash_history or we can use the history command to see the same content. The content of this file is all the commands we have run.","title":"History"},{"location":"custom/#profile","text":"The ~/.bash_profile is a list of Unix commands that are run every time we open our terminal, usually with a different command on every line.","title":"Profile"},{"location":"custom/#setting-alias-commands","text":"One of the most common commands used in a ~/.bash_profile is the alias command, which creates a shorter name for a command. Let\u2019s take a look at a ~/.bash_profile: user@desktop:~$ nano .bash_profile # Command alias docs='cd ~/Documents' # Line added alias edbp='nano ~/.bash_profile' # Line added We add an allias by: alias [alias_name]=\"code\" In order to make the changes to our ~/.bash_profile take effect we need to run source ~/.bash_profile in the console: user@desktop:~$ source ~/.bash_profile # Command user@desktop:~$ docs # Command user@desktop:~/Documents$ # New promt (output of docs)","title":"Setting alias commands"},{"location":"custom/#environmental-variables","text":"The PATH variable contains a sequence of paths on our computer separated by colons. When the shell starts it searches these paths for executable files, and then makes those executable commands available in our shell. One approach to making our scripts available is to add a directory to the PATH. Bash scripts in the directory that are executable can be used as commands. We need to modify PATH every time we start a shell, so we can ammend our ~/.bash_profileso that our directory for executable scripts is always in the PATH. To modify an environmental variable we need to use the export keyword. First let\u2019s create a new directory called Commands in our Codedirectory where we can keep our executable scripts. Then we\u2019ll add a line to our ~/.bash_profile so that Commands is added to the PATH. user@desktop:~$ mkdir Commands user@desktop:~$ echo \"hello world\" > Commands/first.sh user@desktop:~$ nano ~/.bash_profile export PATH=~/Code/Commands:$PATH source ~/.bash_profile","title":"Environmental Variables"},{"location":"help/","text":"Self help MAN (Manuals) Each of the commands that we\u2019ve discussed so far are thoroughly documented, and you can view their documentation using the man command, where the first argument to man is the command you\u2019re curious about. Example : man ls or man cat Controls: Up arrow : Move up Down arrow : Move down / [word/phrase] + Enter : Start search of [word/phrase] Shift + n : search for the next occurrence of the word q : quit Let\u2019s take a look at the documentation for ls: Apropos The man command works wonderfully when you know which command you want to look up, but what if you\u2019ve forgotten the name of the command you\u2019re looking for? You can use apropos [word/phrase] to search all of the available commands and their descriptions. Example let\u2019s pretend that I forgot the name of my favorite command line text editor. You could type apropos editor into the command line which will print a list of results: user@desktop:~$ apropos editor vim (1) -Vi Improved, a programers text editor nano (1) -Restriceted modefor Nano's Another editor","title":"Self help"},{"location":"help/#self-help","text":"","title":"Self help"},{"location":"help/#man-manuals","text":"Each of the commands that we\u2019ve discussed so far are thoroughly documented, and you can view their documentation using the man command, where the first argument to man is the command you\u2019re curious about. Example : man ls or man cat Controls: Up arrow : Move up Down arrow : Move down / [word/phrase] + Enter : Start search of [word/phrase] Shift + n : search for the next occurrence of the word q : quit Let\u2019s take a look at the documentation for ls:","title":"MAN (Manuals)"},{"location":"help/#apropos","text":"The man command works wonderfully when you know which command you want to look up, but what if you\u2019ve forgotten the name of the command you\u2019re looking for? You can use apropos [word/phrase] to search all of the available commands and their descriptions. Example let\u2019s pretend that I forgot the name of my favorite command line text editor. You could type apropos editor into the command line which will print a list of results: user@desktop:~$ apropos editor vim (1) -Vi Improved, a programers text editor nano (1) -Restriceted modefor Nano's Another editor","title":"Apropos"},{"location":"make/","text":"Make files Makefile (makefile) define a set of tasks to be executed. You may have used make to compile a program from source code. Most open source projects use make to compile a final executable binary, which can then be installed using make install. structure The simple makefile has the following general format: [target]: [dependencies...] [commands...] Exmple : user@desktop:~$ nano makefile journal.txt: touch journal.txt In this example, journal.txt is the target, and returns a file which is created as the result of the command(s). It\u2019s very important to note that any commands under a target must be indented with a Tab. If we don\u2019t use Tabs to indent the commands then make will fail. Let\u2019s use the make command with the target we want to be \u201cmade\u201d as the only argument: user@desktop:~$ ls # command makefile # ouput user@desktop:~$ make journal.txt # command touch journal.txt # ouput user@desktop:~$ ls # command makefile # ouput journal.txt # ouput Let\u2019s update our makefile to include a readme.txt that is built automatically. First, let\u2019s add a a dependencie: user@desktop:~$ nano makefile # command journal.txt: touch journal.txt readme.txt: toc.txt echo \"This journal contains the following number of entries:\" > readme.txt wc -l toc.txt | egrep -o \"[0-9]+\" >> readme.txt Now that we have added a new target lets build it user@desktop:~$ make readme.txt # command echo \"This journal contains the following number of entries:\" > readme.txt # output wc -l toc.txt | egrep -o \"[0-9]+\" >> readme.txt # output user@desktop:~$ cat readme.txt # command 1 # output","title":"Make Files"},{"location":"make/#make-files","text":"Makefile (makefile) define a set of tasks to be executed. You may have used make to compile a program from source code. Most open source projects use make to compile a final executable binary, which can then be installed using make install.","title":"Make files"},{"location":"make/#structure","text":"The simple makefile has the following general format: [target]: [dependencies...] [commands...] Exmple : user@desktop:~$ nano makefile journal.txt: touch journal.txt In this example, journal.txt is the target, and returns a file which is created as the result of the command(s). It\u2019s very important to note that any commands under a target must be indented with a Tab. If we don\u2019t use Tabs to indent the commands then make will fail. Let\u2019s use the make command with the target we want to be \u201cmade\u201d as the only argument: user@desktop:~$ ls # command makefile # ouput user@desktop:~$ make journal.txt # command touch journal.txt # ouput user@desktop:~$ ls # command makefile # ouput journal.txt # ouput Let\u2019s update our makefile to include a readme.txt that is built automatically. First, let\u2019s add a a dependencie: user@desktop:~$ nano makefile # command journal.txt: touch journal.txt readme.txt: toc.txt echo \"This journal contains the following number of entries:\" > readme.txt wc -l toc.txt | egrep -o \"[0-9]+\" >> readme.txt Now that we have added a new target lets build it user@desktop:~$ make readme.txt # command echo \"This journal contains the following number of entries:\" > readme.txt # output wc -l toc.txt | egrep -o \"[0-9]+\" >> readme.txt # output user@desktop:~$ cat readme.txt # command 1 # output","title":"structure"},{"location":"reg/","text":"Regular expressions A regular expression (regex or regexp) is a sequence of characters that define a search pattern. Usually such patterns are used by string-searching algorithms for \"find\" or \"find and replace\" operations on strings.The concept arose in the 1950s when the American mathematician Stephen Cole Kleene formalized the description of a regular language. The concept came into common use with Unix text-processing utilities. Regular expressions are used in search engines, search and replace dialogs of word processors and text editors, in text processing utilities. Many programming languages provide regex capabilities either built-in or via libraries. GREP The ability to search through files and folders can greatly improve your productivity using Unix. One of the most popular tools for searching through text files is grep . The simplest use of grep requires two arguments: a string or character you are looking for and the text file to search. grep \"[string/character]\" [file] EGREP Regular expressions aren\u2019t just limited to searching with characters and strings, the real power of regular expressions come from using metacharacters. To take full advantage of all of the metacharacters we should use grep\u2019s cousin egrep , which just extends grep\u2019s capabilities. egrep \"[regular expression]\" [file] FIND If you want to find the location of a file or group of files you can use the find command. find [Directory to start at] [argument] this command has a specific structure where the first argument is the directory where you want to begin the search ( . for current directory, .. for parent director with respect to current directort), and all directories contained within that directory will also be searched. The first argument is then followed by a flag that describes the method you want to use to search. For instance the -name flag. alex@LAPTOP-B501IEC8:/home$ find . -name \"states.txt\" ./alex/states.txt Metacharacters Metacharacters are characters that can be used to represent one ocurrance of any other characters. Metacharacter Meaning . Any Character ^ Beginning of String $ End of String \\n Newline Quantifiers Besides metacharacters that can represent one character, there are also metacharacters called quantifiers which allow you to specify the number of times a particular regular expression should appear in a string. Example: One of the most basic quantifiers is \"+\" which represents one or more occurrences of the preceeding expression. The regular expression \u201cs+as\u201d means: one or more \u201cs\u201d followed by \u201cas\u201d. Let\u2019s see if any of the state names match this expression Metacharacter Meaning + One or More of Previous Character * Zero or More of Previous Character ? Zero or One of Previous Character | Either the Previous or the Following Character {6} Exactly 6 of Previous Character {4, 6} Between 4 and 6 or Previous Character {4, } More than 4 of Previous Character Note: it is important to know the differnece between * and \"*\", the first means all (wildcard) and the second one is a metachacaracter Sets In addition to quantifiers there are also regular expressions for describing sets of characters. Metacharacter Meaning \\w A word (letters, numbers, underscores) \\W Not a Word \\d A Digit (Numbers) \\D Not a Digit \\s Whitespace \\S Not Whitespace [def] A Set of Characters [^def] Negation of Set [e-q] A Range of Characters Wrap up We can us methcaracters to match a single character, quintifiers to match many characters and together we can build sets to match specifc patterns Practical examples: Given a file states.txt with all the sates of the Us we will aply some basic search: Character search example We wish to find all the states that start with \"Miss\" user@desktop:~$ grep \"^Miss\" states.txt Mississippi Missouri Quintifier search example If we apply \"s+as\" we will get back all the states that have a pattern of One or more appearance of \"s\" followed by \"as\" [sas,ssas,sssas,...) user@desktop:~$ egrep \"s+as\" states.txt Arkansas Kansas If we apply \"s*as\" we will get back all the states that have a pattern of zero or more appearance of \"s\" followed by \"as\" [as,sas,ssas,sssas,...) user@desktop:~$ egrep \"s*as\" states.txt Alaska Arkansas Kansas Massachusetts Nebraska Texas Wahington Sets search exmaple Take note that the regular expression \"s{2}\" is equivalent to the regular expression \"ss\",\"s{3}\" to \"sss\" and we can combine them \"s{2,3}[ae]\" to get [\"ssa\",\"sssa\",\"sse\",\"ssse\"] matches user@desktop:~$ egrep \"s{2,3}[ae]\" states.txt Massachusetts Tennesss # matched sss due of typo in Tennessee","title":"Regular Expressions"},{"location":"reg/#regular-expressions","text":"A regular expression (regex or regexp) is a sequence of characters that define a search pattern. Usually such patterns are used by string-searching algorithms for \"find\" or \"find and replace\" operations on strings.The concept arose in the 1950s when the American mathematician Stephen Cole Kleene formalized the description of a regular language. The concept came into common use with Unix text-processing utilities. Regular expressions are used in search engines, search and replace dialogs of word processors and text editors, in text processing utilities. Many programming languages provide regex capabilities either built-in or via libraries.","title":"Regular expressions"},{"location":"reg/#grep","text":"The ability to search through files and folders can greatly improve your productivity using Unix. One of the most popular tools for searching through text files is grep . The simplest use of grep requires two arguments: a string or character you are looking for and the text file to search. grep \"[string/character]\" [file]","title":"GREP"},{"location":"reg/#egrep","text":"Regular expressions aren\u2019t just limited to searching with characters and strings, the real power of regular expressions come from using metacharacters. To take full advantage of all of the metacharacters we should use grep\u2019s cousin egrep , which just extends grep\u2019s capabilities. egrep \"[regular expression]\" [file]","title":"EGREP"},{"location":"reg/#find","text":"If you want to find the location of a file or group of files you can use the find command. find [Directory to start at] [argument] this command has a specific structure where the first argument is the directory where you want to begin the search ( . for current directory, .. for parent director with respect to current directort), and all directories contained within that directory will also be searched. The first argument is then followed by a flag that describes the method you want to use to search. For instance the -name flag. alex@LAPTOP-B501IEC8:/home$ find . -name \"states.txt\" ./alex/states.txt","title":"FIND"},{"location":"reg/#metacharacters","text":"Metacharacters are characters that can be used to represent one ocurrance of any other characters. Metacharacter Meaning . Any Character ^ Beginning of String $ End of String \\n Newline","title":"Metacharacters"},{"location":"reg/#quantifiers","text":"Besides metacharacters that can represent one character, there are also metacharacters called quantifiers which allow you to specify the number of times a particular regular expression should appear in a string. Example: One of the most basic quantifiers is \"+\" which represents one or more occurrences of the preceeding expression. The regular expression \u201cs+as\u201d means: one or more \u201cs\u201d followed by \u201cas\u201d. Let\u2019s see if any of the state names match this expression Metacharacter Meaning + One or More of Previous Character * Zero or More of Previous Character ? Zero or One of Previous Character | Either the Previous or the Following Character {6} Exactly 6 of Previous Character {4, 6} Between 4 and 6 or Previous Character {4, } More than 4 of Previous Character Note: it is important to know the differnece between * and \"*\", the first means all (wildcard) and the second one is a metachacaracter","title":"Quantifiers"},{"location":"reg/#sets","text":"In addition to quantifiers there are also regular expressions for describing sets of characters. Metacharacter Meaning \\w A word (letters, numbers, underscores) \\W Not a Word \\d A Digit (Numbers) \\D Not a Digit \\s Whitespace \\S Not Whitespace [def] A Set of Characters [^def] Negation of Set [e-q] A Range of Characters","title":"Sets"},{"location":"reg/#wrap-up","text":"We can us methcaracters to match a single character, quintifiers to match many characters and together we can build sets to match specifc patterns","title":"Wrap up"},{"location":"reg/#practical-examples","text":"Given a file states.txt with all the sates of the Us we will aply some basic search:","title":"Practical examples:"},{"location":"reg/#character-search-example","text":"We wish to find all the states that start with \"Miss\" user@desktop:~$ grep \"^Miss\" states.txt Mississippi Missouri","title":"Character search example"},{"location":"reg/#quintifier-search-example","text":"If we apply \"s+as\" we will get back all the states that have a pattern of One or more appearance of \"s\" followed by \"as\" [sas,ssas,sssas,...) user@desktop:~$ egrep \"s+as\" states.txt Arkansas Kansas If we apply \"s*as\" we will get back all the states that have a pattern of zero or more appearance of \"s\" followed by \"as\" [as,sas,ssas,sssas,...) user@desktop:~$ egrep \"s*as\" states.txt Alaska Arkansas Kansas Massachusetts Nebraska Texas Wahington","title":"Quintifier search example"},{"location":"reg/#sets-search-exmaple","text":"Take note that the regular expression \"s{2}\" is equivalent to the regular expression \"ss\",\"s{3}\" to \"sss\" and we can combine them \"s{2,3}[ae]\" to get [\"ssa\",\"sssa\",\"sse\",\"ssse\"] matches user@desktop:~$ egrep \"s{2,3}[ae]\" states.txt Massachusetts Tennesss # matched sss due of typo in Tennessee","title":"Sets search exmaple"},{"location":"ssh/","text":"Secure Shell Secure Shell (SSH) is a cryptographic network protocol for operating network services securely over an unsecured network. Typical applications include remote command-line, login, and remote command execution, but any network service can be secured with SSH. SSH provides a secure channel over an unsecured network by using a client\u2013server architecture, connecting an SSH client application with an SSH server. The protocol specification distinguishes between two major versions, referred to as SSH-1 and SSH-2. The standard TCP port for SSH is 22. SSH is generally used to access Unix-like operating systems, but it can also be used on Microsoft Windows. Windows 10 uses OpenSSH as its default SSH client and SSH server. Conect using ssh First you gotta make sure that the deivce you want to connect has ssh enabeled, in this example we will connect to a raspberry pi 4 user@desktop:~$ ssh [user]@[ip address] [user]@[ip address]'s password: ************ pi@user:~ $ Once we have established the conection we have gained remote acces to our raspberry pi. Sending files via SSH scp (secure copy) command in Linux system is used to copy file(s) between servers in a secure way. The SCP command or secure copy allows secure transferring of files in between the local host and the remote host or between two remote hosts. Sending files from local computer to remote computer scp path/on/my/computer [username]@[IP address]:path/to/file/on/server Sending files from remote computer to local computer Login using SSH scp [username]@[IP address]:path/to/file/on/server path/on/my/computer Close SSH connection In orer to close the secure conextion we established we can type ~. that is it.","title":"Secure Shell"},{"location":"ssh/#secure-shell","text":"Secure Shell (SSH) is a cryptographic network protocol for operating network services securely over an unsecured network. Typical applications include remote command-line, login, and remote command execution, but any network service can be secured with SSH. SSH provides a secure channel over an unsecured network by using a client\u2013server architecture, connecting an SSH client application with an SSH server. The protocol specification distinguishes between two major versions, referred to as SSH-1 and SSH-2. The standard TCP port for SSH is 22. SSH is generally used to access Unix-like operating systems, but it can also be used on Microsoft Windows. Windows 10 uses OpenSSH as its default SSH client and SSH server.","title":"Secure Shell"},{"location":"ssh/#conect-using-ssh","text":"First you gotta make sure that the deivce you want to connect has ssh enabeled, in this example we will connect to a raspberry pi 4 user@desktop:~$ ssh [user]@[ip address] [user]@[ip address]'s password: ************ pi@user:~ $ Once we have established the conection we have gained remote acces to our raspberry pi.","title":"Conect using ssh"},{"location":"ssh/#sending-files-via-ssh","text":"scp (secure copy) command in Linux system is used to copy file(s) between servers in a secure way. The SCP command or secure copy allows secure transferring of files in between the local host and the remote host or between two remote hosts. Sending files from local computer to remote computer scp path/on/my/computer [username]@[IP address]:path/to/file/on/server Sending files from remote computer to local computer Login using SSH scp [username]@[IP address]:path/to/file/on/server path/on/my/computer","title":"Sending files via SSH"},{"location":"ssh/#close-ssh-connection","text":"In orer to close the secure conextion we established we can type ~. that is it.","title":"Close SSH connection"}]}